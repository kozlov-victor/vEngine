this.blendModes[CONST.BLEND_MODES.NORMAL] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
this.blendModes[CONST.BLEND_MODES.ADD] = [gl.ONE, gl.DST_ALPHA];
this.blendModes[CONST.BLEND_MODES.MULTIPLY] = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA];
this.blendModes[CONST.BLEND_MODES.SCREEN] = [gl.ONE, gl.ONE_MINUS_SRC_COLOR];
this.blendModes[CONST.BLEND_MODES.OVERLAY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
this.blendModes[CONST.BLEND_MODES.DARKEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
this.blendModes[CONST.BLEND_MODES.LIGHTEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
this.blendModes[CONST.BLEND_MODES.COLOR_DODGE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
this.blendModes[CONST.BLEND_MODES.COLOR_BURN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
this.blendModes[CONST.BLEND_MODES.HARD_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
this.blendModes[CONST.BLEND_MODES.SOFT_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
this.blendModes[CONST.BLEND_MODES.DIFFERENCE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
this.blendModes[CONST.BLEND_MODES.EXCLUSION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
this.blendModes[CONST.BLEND_MODES.HUE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
this.blendModes[CONST.BLEND_MODES.SATURATION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
this.blendModes[CONST.BLEND_MODES.COLOR] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
this.blendModes[CONST.BLEND_MODES.LUMINOSITY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];

Add the following code to compute the color for each pixel:
void main(void) {
 // texel color look up based on interpolated UV value in vTexCoord
 vec4 c = texture2D(uSampler, vec2(vTexCoord.s, vTexCoord.t));
 
 // tint the textured area. Leave transparent area as defined by the texture
 vec3 r = vec3(c) * (1.0-uPixelColor.a) + vec3(uPixelColor) * uPixelColor.a;
 vec4 result = vec4(r, c.a);
 gl_FragColor = result;
 
 
 
 on to activate a WebGL texture for drawing.
var activateTexture = function (textureName) {
 var gl = gEngine.Core.getGL();
 var texInfo = gEngine.ResourceMap.retrieveAsset(textureName);
 // Binds our texture reference to the current webGL texture functionality
 gl.bindTexture(gl.TEXTURE_2D, texInfo.mGLTexID);
 
 // To prevent texture wrappings
 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
 // Handles how magnification and minimization filters will work.
 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
 // For pixel-graphics where you want the texture to look "sharp" 
// do the following:
 // gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
 // gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
 };




 
vec2 uv = vec2(gl_FragCoord.xy / vec2(rt_w,rt_h));
vec2 p= vec2(floor(gl_FragCoord.x), floor(gl_FragCoord.y));
if (mod(p.y, 2.0)==0.0)
   gl_FragColor = blur(uv);
else
   gl_FragColor = vec4(0.0,0.0,0.0,1.0);



this.posCorrection = this.posCorrection|| 0;
this.posCorrectionDelta = this.posCorrectionDelta || 0;
if (gameObject['_lastDirection'] === 'Right')
    this.posCorrectionDelta=5; // todo _lastDirection
if (gameObject['_lastDirection'] === 'Left')
    this.posCorrectionDelta=-5;
this.posCorrection+=this.posCorrectionDelta;
let maxCorrection = w/4;
if (this.posCorrection>maxCorrection) this.posCorrection = maxCorrection;
if (this.posCorrection<-maxCorrection) this.posCorrection = -maxCorrection;

newPos.x = this.pos.x+(pointToFollow.x + this.posCorrection - this.pos.x)*0.1;
newPos.y = this.pos.y+(pointToFollow.y - this.pos.y)*0.1;
if (newPos.x < 0)
    newPos.x = 0;
if (newPos.y < 0)
    newPos.y = 0;
if (newPos.x > this.sceneWidth - w + tileWidth)
    newPos.x = this.sceneWidth - w + tileWidth;
if (newPos.y > this.sceneHeight - h + tileHeight)
    newPos.y = this.sceneHeight - h + tileHeight;

this.pos.setXY(newPos.x,newPos.y);